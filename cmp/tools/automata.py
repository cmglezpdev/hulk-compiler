# import zlib, base64
# exec(zlib.decompress(base64.b64decode('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')))
# # Created by pyminifier (https://github.com/liftoff/pyminifier)
import pydot    
from cmp.utils import ContainerSet, DisjointSet


class NFA:
    def __init__(self, states, finals, transitions, start=0):
        self.states = states
        self.start = start
        self.finals = set(finals)
        self.map = transitions
        self.vocabulary = set()
        self.transitions = { state: {} for state in range(states) }
        
        for (origin, symbol), destinations in transitions.items():
            assert hasattr(destinations, '__iter__'), 'Invalid collection of states'
            self.transitions[origin][symbol] = destinations
            self.vocabulary.add(symbol)
            
        self.vocabulary.discard('')
        
    def epsilon_transitions(self, state):
        assert state in self.transitions, 'Invalid state'
        try:
            return self.transitions[state]['']
        except KeyError:
            return ()
            
    def graph(self):
        G = pydot.Dot(rankdir='LR', margin=0.1)
        G.add_node(pydot.Node('start', shape='plaintext', label='', width=0, height=0))

        for (start, tran), destinations in self.map.items():
            tran = 'Îµ' if tran == '' else tran
            G.add_node(pydot.Node(start, shape='circle', style='bold' if start in self.finals else ''))
            for end in destinations:
                G.add_node(pydot.Node(end, shape='circle', style='bold' if end in self.finals else ''))
                G.add_edge(pydot.Edge(start, end, label=tran, labeldistance=2))

        G.add_edge(pydot.Edge('start', self.start, label='', style='dashed'))
        return G

    def _repr_svg_(self):
        try:
            return self.graph().create_svg().decode('utf8')
        except Exception as e:
            print(e)
            pass        
class DFA(NFA):
    
    def __init__(self, states, finals, transitions, start=0):
        assert all(isinstance(value, int) for value in transitions.values())
        assert all(len(symbol) > 0 for origin, symbol in transitions)
        
        transitions = { key: [value] for key, value in transitions.items() }
        NFA.__init__(self, states, finals, transitions, start)
        self.current = start
        
    def _move(self, symbol):
        try:
            self.current = self.transitions[self.current][symbol][0]
            return self.current
        except:  # noqa: E722
            self.current = None
            return None

        
        
    def _reset(self):
        self.current = self.start
        
    def recognize(self, string):
        self._reset()
        for s in string:
            next = self._move(s)
            if next is None:
                return False
        return self.current in self.finals
        


def move(automaton, states, symbol):
    moves = set()
    for state in states:
        if symbol in automaton.transitions[state]:
            [moves.add(s) for s in automaton.transitions[state][symbol]]
    return moves

def epsilon_closure(automaton, states):
    pending = [ s for s in states ]
    closure = { s for s in states } 
    
    while pending:
        state = pending.pop()
        for s in automaton.epsilon_transitions(state):
            if s not in closure:
                closure.add(s)
                pending.append(s)
            
    return ContainerSet(*closure)

def nfa_to_dfa(automaton):
    transitions = {}
    
    start = epsilon_closure(automaton, [automaton.start])
    start.id = 0
    start.is_final = any(s in automaton.finals for s in start)
    states = [ start ]

    pending = [ start ]
    while pending:
        state = pending.pop()
        
        for symbol in automaton.vocabulary:
            moves = move(automaton, state, symbol)
            closure = epsilon_closure(automaton, moves)
            if not closure:
                continue
            
            if closure not in states:
                closure.id = len(states)
                closure.is_final = any(s in automaton.finals for s in closure)
                states.append(closure)
                pending.append(closure)
            else:
                index = states.index(closure)
                closure = states[index]
                
            try:
                transitions[state.id, symbol]
                assert False, 'Invalid DFA!!!'
            except KeyError:
                transitions[state.id, symbol] = closure.id
    
    finals = [ state.id for state in states if state.is_final ]
    dfa = DFA(len(states), finals, transitions)
    return dfa

def automata_union(a1, a2):
    transitions = {}
    
    start = 0
    d1 = 1
    d2 = a1.states + d1
    final = a2.states + d2
    
    for (origin, symbol), destinations in a1.map.items():
        ## Relocate a1 transitions ...
        transitions[(origin + d1, symbol)] = [state + d1 for state in destinations]        

    for (origin, symbol), destinations in a2.map.items():
        ## Relocate a2 transitions ...
        transitions[(origin + d2, symbol)] = [state + d2 for state in destinations]    
    
    ## Add transitions from start state ...
    transitions[(start, '')] = [a1.start + d1, a2.start + d2]

    ## Add transitions to final state ...
    for f in a1.finals:
        transitions[(f + d1, '')] = [final]
    for f in a2.finals:
        transitions[(f + d2, '')] = [final]

    states = a1.states + a2.states + 2
    finals = { final }
    
    return NFA(states, finals, transitions, start)

def automata_concatenation(a1, a2):
    transitions = {}
    
    start = 0
    d1 = 0
    d2 = a1.states + d1
    final = a2.states + d2
    
    transitions[(start, '')] = [a1.start + d1]
    
    for (origin, symbol), destinations in a1.map.items():
        ## Relocate a1 transitions ...
        transitions[(origin + d1, symbol)] = [state + d1 for state in destinations]

    for (origin, symbol), destinations in a2.map.items():
        ## Relocate a2 transitions ...
        transitions[(origin + d2, symbol)] = [state + d2 for state in destinations]
    
    ## Add transitions to final state ...
    for state in a1.finals:
        try:
            transitions[(state + d1, '')].append(a2.start + d2)
        except:
            transitions[(state + d1, '')] = [a2.start + d2]
    
    for state in a2.finals:
        try:
            transitions[(state + d2, '')].append(final)
        except:
            transitions[(state + d2, '')] = [final]

    states = a1.states + a2.states + 1
    finals = { final }
    
    return NFA(states, finals, transitions, start)

def automata_closure(a1):
    transitions = {}
    
    start = 0
    d1 = 1
    final = a1.states + d1
    
    for (origin, symbol), destinations in a1.map.items():
        ## Relocate automaton transitions ...
        transitions[(origin + d1, symbol)] = [state + d1 for state in destinations]
    
    ## Add transitions from start state ...
    transitions[(start, '')] = [a1.start + d1, final]
    
    ## Add transitions to final state and to start state ...
    for state in a1.finals:
        transitions[(state + d1, '')] = [start, final]

    states = a1.states +  2
    finals = { final }
    
    return NFA(states, finals, transitions, start)






def distinguish_states(group, automaton, partition):
    split = {}
    vocabulary = tuple(automaton.vocabulary)
    
    for member in group:
        # take its transitions
        member_trans = automaton.transitions[member.value]
        # por cada simbolo, si el miembro tiene una transicion desde el con ese simbolo, entonces tomo cualquiera(el primero en este caso)
        # o sea, una tupla con el nodo vecino por cada simbolo (es un solo nodo vecino xq el automata es determinista) 
        reach_states = tuple((member_trans[s][0] if s in member_trans else None) for s in vocabulary)
        # por cada estado alcanzable, me quedo con el grupo al que pertence cada estado
        # o sea, una tupla con el grupo al que pertenece cada estado
        reach_s_groups = tuple((partition[state].representative if state in partition.nodes else None) for state in reach_states)

        # se agrupan todos los nodos con los mismos grupos alcanzables
        try:
            split[reach_s_groups].append(member.value)
        except KeyError:
            split[reach_s_groups] = [member.value]

    return [ group for group in split.values()]
            
def state_minimization(automaton):
    partition = DisjointSet(*range(automaton.states))
    
    # create initial groups (FINALS AND NOT FINALS STATES)
    partition.merge(s for s in automaton.finals)
    partition.merge(s for s in range(automaton.states) if s not in automaton.finals)
    
    while True:
        new_partition = DisjointSet(*range(automaton.states))
        ## Split each group if needed (use distinguish_states(group, automaton, partition))
        for group in partition.groups:
            for dist_states in distinguish_states(group, automaton, partition):
                new_partition.merge(dist_states)

        if len(new_partition) == len(partition):
            break

        partition = new_partition
        
    return partition

def automata_minimization(automaton):
    partition = state_minimization(automaton)
    
    states = [r for r in partition.representatives]
    
    transitions = {}
    for i, state in enumerate(states):
        origin = state.value

        for symbol, destinations in automaton.transitions[origin].items():
            rep = partition[destinations[0]].representative
            goto = states.index(rep)
            
            try:
                transitions[i, symbol]
                assert False, 'Another transition from i with the same symbol(Is a NFA)'
            except KeyError:
                transitions[i, symbol] = goto
                pass
    
    finals = [i for i, state in enumerate(states) if state.value in automaton.finals]
    start  = states.index(partition[automaton.start].representative)
    
    return DFA(len(states), finals, transitions, start)

